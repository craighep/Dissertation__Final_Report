\chapter{Evaluation}
Upon completion of the application, it is now nessecary to evaluate both the application and project as a whole. This section will address a number of topics, in order to grasp an overall effectivness of the project. For the purposes of highliting points such as how well requirements were set out, or how well the application fulfilled its purpose, this evaluation has been broken down into the principle stages of the project. At the end, a small self-evaluation will describe what the author of this paper and application has felt was learned through this project in terms of personal and technical achievements.

\section{Anlaysis and design decisions}
Firstly, answering the question of how successful gathering requirements, the process of this started with looking at the initial project choice and language choice. After giving a brief overview of what the purpose and reasoning for this project, the language choice was an easy decision becuase WebGL could only run under the JavaScript lanuage. Identifying this, analysing what technolodgies to use was then found to be much easier. 

The amount of research into the background topics was to a good amount that lead up to the discovery of the 15 dgree increments idea (though later revised to 45 for interpolation issues), and meetings ensured that a sensible list of feature sets were created. By preparing quetsions in the inital project specification, having meetings clarified some of the technolodgy choices, and discovered in more detail functions required of the application. In addition to the research shown in the primary report, the appendix added a even greater level of detail into the research of OLAN, and the expect Aresti figures to be generated.

The use of techniques such as the prioirtised list of features from the scrum methodolodgy helped in the implementation stage, by ensuring only important features were created first, so that the basic principles of the application were in place before any additonal appearence or functionaly extras were added. Although the style of organising tasks this way is part of scrum, 

Looking at the methodology choice in more detail, the reaosning for create a hybrid of the waterfall and feature driven was backed up for personal views towards the two processes, and technical effeciency reasons. By outlining the process in as much detail as possible ensured that the project allowed the design, implementation and testing phases to follow a strict plan. In order to support the methodology choice, both project and implemtation Gantt charts helped to show where the project would be divided in terms of project time. Where this assignment was more heavily weighted towards implementation and testing, this was taken into account when assigning amounts of project time.

Diagrams helped tremendously in designing the project, and in organising features. The first to be used was the use case diagram that was created to represent the features decided earlier, and to help categorise the features into feature sets. Feature sets were useful later on where wireframes planned which options would be together. For instance, keeping the input of OLAN and the play/pause button together proved useful in the final application, and was placed so due to the planning using the use-case.

Other diagrams incuded the model view controller pattern mock-up, which provided the design for how the application would interact with the front and back end. Using the MVC diagram, it was possible to see what kind of general modules or classes would be required to run the application and communicate with the canvas. The MVC pattern also paved the way to introduce the idea of using a whole set of different design patterns, such as the observer pattern, whcih like MVC provided a way of connecting with front-end elements whilst keeping the model unaware of the them. A lot of research into various design patterns possible for JavaScript was taken into account, with reasoning given for choosing to use or not to use different patterns.

Because it had already been noted that JavaScript was a classless language, choosing to use modulation as a means of organising and simulationg object-orientation was selected. Becuase modulation was similar to the way classes worked, a class diagram felt most appropriate for dispalying that aspect of the design. It was important to correctly identify which features should have had their own controllers and modules, becuase the coding was then be based heavily on the diagram.

Further resarch that helped structure of the requirements was the design of the GUI itself, planning firstly where features should display, and how each should interact in what order. Creating a GUI use case allowed for good detailed mock ups of the page, and identified where features were best suited. Again, this then made the implementation stage much easier and quicker to do when it came to placing features from the back end onto the GUI. A flow diagram also helped identify how the speed of various parts of the system might affect the time from opening the page to allowing users to input into the OLAN box. It was important to ensure that proper loading of the application would be complete before allowing use, as it would prevent users from crashing the application.

Researching into some of the technologies before begginning implementation also helped a great deal later on in the project, as it reduced set up time for items like RequireJS. By browsing example applcations and work online also using Three.js, it gave a wider more general idea on what the most effiecent way of creating a Three.js application, and what practices to follow. This was the same for the plain JavaScript code, where items such as local storage were researched and samples viewed before thinking how this application could implement them.

And to complete the anaylsis of the proposed applicaton effectivly, planning what technologies would be helpful to use during implementation was evaluated. By going to the smallest of detail, from selecting the version control to the IDE meant that when the project would move into the implementation stage, a clear path could be followed.

\section{Application and testing evaluation}
The second section of the project evaluation concerns how well the methodolodgy was put to use, and overall, how successfull the completed application was at fulfilling requirements. As FDD would be the principle means of implementation, an iteration approach to creating each feature set was used. At the start of the section, the iteration method was outlined, to ensure that each iteration followed the same procedures and testing methods. By doing this, it made sure that the time given to each task was fair and gave as best possible to finish as many features as possible.

As it can be seen in the section itself, not all features were completed initially, with some issues and features remaining missing even at the end of the time given to implementation.
%unit and usabilut tests, improvements
%user questinnaire
%status at end - did it fill requirements
%mini test and impl review

\section{Project improvements}
Now that the walkthrough of the project has been completed, each detailed with issues highlighted, there are some possible improvements that could have been made to the way the project was done if it was started again knowing what happened the first time.
%more planning?
%could better tools have been used
%smaller feature sets
%different library to three.js

\section{Self-Evaluation}
For this final section of the report, I the author can now evaluate my own personal experiences whilst creating the application. I will explain what skills were developed through my time during the project, and what if any I struggled to get working or working in a desired way.
%technologies used, diagram creators
%what i learnt
%if you were starting again...


   %\item How well did the software meet the needs of those who were expecting to use it?

   %\item How well were any other project aims achieved? Testingggggggg
